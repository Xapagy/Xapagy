/* XapiLang.java */
/* Generated By:JavaCC: Do not edit this line. XapiLang.java */
package org.xapagy.xapi.language.parser;
import java.io.File;
import java.io.IOException;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;


import org.xapagy.activity.DaHelper;
import org.xapagy.activity.DaComposite;
import org.xapagy.activity.SaHelper;
import org.xapagy.activity.SaComposite;
import org.xapagy.agents.Agent;
import org.xapagy.agents.PerformanceMeter;
import org.xapagy.xapi.Kludges;
import org.xapagy.xapi.KludgeCreateLink;
import org.xapagy.xapi.XapiDictionary;
import org.xapagy.autobiography.ABStory;
import org.xapagy.xapi.MacroGenerator;
import org.xapagy.xapi.XapiFileLoader;
import org.xapagy.parameters.Parameters;
import org.xapagy.ui.SaveLoadUtil;
import org.xapagy.ui.TextUi;
import org.xapagy.ui.prettyprint.PpStory;
import org.xapagy.links.Links;
import org.xapagy.debug.ViMatchFilter;
import org.xapagy.ui.observers.XapiObserver;
import org.xapagy.debug.DebugEvent.DebugEventType;
import org.xapagy.instances.Instance;
import org.xapagy.concepts.Concept;
import org.xapagy.concepts.ConceptDataBaseHelper;
import org.xapagy.concepts.ConceptOverlay;
import org.xapagy.concepts.Verb;
import org.xapagy.concepts.Hardwired;
import org.xapagy.concepts.VerbOverlay;
import org.xapagy.concepts.AbstractConceptDB;
import org.xapagy.domain.IncludeHelper;
import org.xapagy.ui.observers.AbstractAgentObserver.TraceWhat;
import org.xapagy.ui.observers.ToStringObserver;
import org.xapagy.exceptions.NoSuchConceptOrVerb;
import org.xapagy.set.EnergyColors;


@SuppressWarnings({"all"})
public class XapiLang implements XapiLangConstants {

   private Agent agent;
   private ConceptDataBaseHelper<Concept> cdh;
   private ConceptDataBaseHelper<Verb> vdh;

   public void setAgent(Agent agent) {
       this.agent = agent;
       cdh = new ConceptDataBaseHelper<Concept>(agent.getConceptDB(),
                        ConceptDataBaseHelper.ContentType.TYPE_CONCEPT, agent);
       vdh = new ConceptDataBaseHelper<Verb>(agent.getVerbDB(),
               ConceptDataBaseHelper.ContentType.TYPE_VERB, agent);

   }

/* The whole change specification */
  final public void line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 20:
    case 21:{
      documentation();
      break;
      }
    case ID:
    case LABEL:
    case STRING_DOUBLE_QUOTES:
    case STRING_SINGLE_QUOTES:{
      statement();
      break;
      }
    case 19:{
      debugHere();
      break;
      }
    case 22:{
      sceneCreate();
      break;
      }
    case 29:{
      changeScene();
      break;
      }
    case 30:{
      checkPoint();
      break;
      }
    case 31:{
      define();
      break;
      }
    case 32:{
      include();
      break;
      }
    case 35:{
      createLinkType();
      break;
      }
    case 43:{
      createLink();
      break;
      }
    case 47:
    case 48:{
      parameter();
      break;
      }
    case 55:{
      energyCreate();
      break;
      }
    case 59:{
      performanceMeter();
      break;
      }
    case 60:
    case 61:{
      create();
      break;
      }
    case 91:{
      observer();
      break;
      }
    case 79:{
      diffusionActivity();
      break;
      }
    case 89:{
      spikeActivity();
      break;
      }
    case 97:{
      print();
      break;
      }
    case 98:{
      namespace();
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(0);
  }

/* statement: a statement that can be an S-V-O, S-V, S-Adj, Quote */
  final public void statement() throws ParseException {
    cospecInStatement();
    jj_consume_token(8);
    vospecInStatement();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 8:{
      jj_consume_token(8);
      cospecInStatement();
      terminator();
      break;
      }
    case 16:
    case 17:
    case 18:{
      terminator();
      break;
      }
    case 9:{
      jj_consume_token(9);
      cospecInStatement();
      terminator();
      break;
      }
    case 10:{
      jj_consume_token(10);
      cospecInStatement();
      jj_consume_token(11);
      statement();
      break;
      }
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* this returns the cospec as a string. Eventually, we need to migrate to 
   actually do proper parsing here, but in order to make a smooth transition, 
   we will do this for the time being */
  final public String cospecInStatement() throws ParseException {String accumulate = "";
    Token t;
    String value;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING_DOUBLE_QUOTES:
      case STRING_SINGLE_QUOTES:{
        value = string_literal();
accumulate += value + " ";
        break;
        }
      case ID:{
        t = jj_consume_token(ID);
accumulate += t.image + " ";
        break;
        }
      case LABEL:{
        t = jj_consume_token(LABEL);
accumulate += t.image + " ";
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:
      case LABEL:
      case STRING_DOUBLE_QUOTES:
      case STRING_SINGLE_QUOTES:{
        ;
        break;
        }
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
    }
{if ("" != null) return accumulate.trim();}
    throw new Error("Missing return statement in function");
  }

  final public void vospecInStatement() throws ParseException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case STRING_DOUBLE_QUOTES:
      case STRING_SINGLE_QUOTES:{
        string_literal();
        break;
        }
      case ID:{
        jj_consume_token(ID);
        break;
        }
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ID:
      case STRING_DOUBLE_QUOTES:
      case STRING_SINGLE_QUOTES:{
        ;
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
    }
  }

/* parses a relation between scenes */
  final public String relationSpec() throws ParseException {String relation;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 12:{
      jj_consume_token(12);
relation = "none";
      break;
      }
    case 13:{
      jj_consume_token(13);
relation = "successor";
      break;
      }
    case 14:{
      jj_consume_token(14);
relation = "view";
      break;
      }
    case 15:{
      jj_consume_token(15);
relation = "fictional-future";
      break;
      }
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return relation;}
    throw new Error("Missing return statement in function");
  }

  final public void terminator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 16:{
      jj_consume_token(16);
      break;
      }
    case 17:{
      jj_consume_token(17);
      break;
      }
    case 18:{
      jj_consume_token(18);
      break;
      }
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* enter into debugging mode here */
  final public void debugHere() throws ParseException {
    jj_consume_token(19);
Kludges.kludgeDebugHere(agent);
  }

/* accumulates documentation */
  final public void documentation() throws ParseException {String newdoc;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 20:{
      jj_consume_token(20);
      break;
      }
    case 21:{
      jj_consume_token(21);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    newdoc = string_literal_content();
agent.setDocumentation(agent.getDocumentation() + " " + newdoc);
  }

/* create a new scene and make it current */
  final public void sceneCreate() throws ParseException {String localFrom;
   String localTo;
   Token t;
   String newSceneLabel;
   String relation = "none";
   List<SimpleEntry<String, String>> participants = new ArrayList<SimpleEntry<String, String>>();
   boolean makeCurrent = false;
   boolean addSummary = false;
   boolean onlyScene = false;
    jj_consume_token(22);
    t = jj_consume_token(LABEL);
newSceneLabel = t.image;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 23:{
      jj_consume_token(23);
makeCurrent = true;
      break;
      }
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 24:{
      jj_consume_token(24);
// if the closeothers is on, makeCurrentMust be on
       onlyScene = true;
       makeCurrent = true;
      break;
      }
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 25:{
      jj_consume_token(25);
addSummary = true;
      break;
      }
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 26:{
      jj_consume_token(26);
      relation = relationSpec();
      break;
      }
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 27:{
      jj_consume_token(27);
      localFrom = cospecInStatement();
localTo=null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 28:{
        jj_consume_token(28);
        localTo = cospecInStatement();
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        ;
      }
SimpleEntry<String, String> entry1 = new SimpleEntry<String, String>(localFrom, localTo);
                                       participants.add(entry1);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 17:{
          ;
          break;
          }
        default:
          jj_la1[14] = jj_gen;
          break label_3;
        }
        jj_consume_token(17);
        localFrom = cospecInStatement();
localTo=null;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 28:{
          jj_consume_token(28);
          localTo = cospecInStatement();
          break;
          }
        default:
          jj_la1[15] = jj_gen;
          ;
        }
SimpleEntry<String, String> entry = new SimpleEntry<String, String>(localFrom, localTo);
       participants.add(entry);
      }
      break;
      }
    default:
      jj_la1[16] = jj_gen;
      ;
    }
ABStory generated =
                    MacroGenerator.generateNewScene(agent, newSceneLabel,
                            makeCurrent, onlyScene, addSummary, relation,
                            participants);
     TextUi.println(PpStory.pp("Generated:", generated));
     agent.getLoop().addImmediateReading(generated.getLines());
  }

/* changes the default scene to another scene */
  final public void changeScene() throws ParseException {Token t;
    jj_consume_token(29);
    t = jj_consume_token(LABEL);
Instance target = null;
      String sceneLabelReal = agent.getLabelSpaces().fullLabel(t.image);
      for (Instance scene : agent.getFocus().getSceneListAllEnergies()) {
            if (scene.getConcepts().getLabels().contains(sceneLabelReal)) {
                target = scene;
                break;
            }
      }
      if (target == null) {
            {if (true) throw new Error("Could not find scene with label " + sceneLabelReal + " (expanded from " + t.image + ")");}
      }
      agent.getFocus().setCurrentScene(target);
  }

// parses a filename into a file
  final public File fileSpec() throws ParseException {String fileName;
    fileName = string_literal_content();
File f = new File(fileName);
      {if ("" != null) return f;}
    throw new Error("Missing return statement in function");
  }

/* checkpoints Xapagy at this point */
  final public void checkPoint() throws ParseException {File f;
    jj_consume_token(30);
    f = fileSpec();
agent.getLoop().setRequestedCheckPointFile(f);
  }

  final public void define() throws ParseException {Token t = null;
    jj_consume_token(31);
    t = jj_consume_token(ID);
agent.getLabelSpaces().getDefines().add(t.image);
  }

/* includes another Xapi file and queues it up for reading here. If the 
   IfNotDefined clause is there, it does not include it if in the agent's domain 
   list the term is already defined (with a previous $Define */
  final public void include() throws ParseException {String includeSpec;
   Token t = null;
   String marker = null;
    jj_consume_token(32);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 33:{
      jj_consume_token(33);
      marker = string_literal_content();
      break;
      }
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 34:{
      jj_consume_token(34);
      t = jj_consume_token(ID);
      break;
      }
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    includeSpec = string_literal_content();
File f = IncludeHelper.findXapiFile(includeSpec);
            if (t != null) {
                String domain = t.image;
                if (agent.getLabelSpaces().getDefines().contains(domain)) {
                        {if ("" != null) return;}
                }
            }
        try {
                XapiFileLoader.loadFileToReading(agent, f, marker);
        } catch (IOException e) {
            e.printStackTrace();
            TextUi.println("$Include statement but could not find file"
                    + f.getAbsolutePath());
            {if (true) throw new Error("$Include statement but could not find file"
                    + f.getAbsolutePath());}
        }
  }

/*
   Creates a match filter: right now it just picks up a string, and passes it to the
   old match filter, but later we need to make this one a lot more flexible.
*/
  final public ViMatchFilter viMatchFilter() throws ParseException {String text;
   ViMatchFilter linkName;
    text = string_literal_content();
ViMatchFilter retval = ViMatchFilter.createViMatchFilter(null, text);
      {if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/* create a new link type */
  final public void createLinkType() throws ParseException {
    jj_consume_token(35);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 36:{
      createLinkTypeOneWay();
      break;
      }
    case 42:{
      createLinkTypeUndirected();
      break;
      }
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* remaining of the create link type statement for oneway links */
  final public void createLinkTypeOneWay() throws ParseException {String linkTypeName;
        String reverse;
        double defaultWeight;
        double reverseDefaultWeight;
    jj_consume_token(36);
    linkTypeName = string_literal_content();
    jj_consume_token(37);
    jj_consume_token(38);
    jj_consume_token(39);
    defaultWeight = number();
    jj_consume_token(40);
    jj_consume_token(41);
    reverse = string_literal_content();
    jj_consume_token(37);
    jj_consume_token(38);
    jj_consume_token(39);
    reverseDefaultWeight = number();
String documentation = agent.getDocumentation();
              agent.setDocumentation("");
          agent.getLinks().createDirectionPairedLinkTypes(linkTypeName, defaultWeight, reverse, reverseDefaultWeight, documentation);
  }

/* remaining of the create link type statement for undirected links */
  final public void createLinkTypeUndirected() throws ParseException {String linkTypeName;
        double defaultWeight;
    jj_consume_token(42);
    linkTypeName = string_literal_content();
    jj_consume_token(37);
    jj_consume_token(38);
    jj_consume_token(39);
    defaultWeight = number();
String documentation = agent.getDocumentation();
                agent.setDocumentation("");
                agent.getLinks().createRegularLinkType(linkTypeName, defaultWeight, documentation);
  }

/* manually create a link */
  final public void createLink() throws ParseException {KludgeCreateLink.CreateLinkSpec spec = new KludgeCreateLink.CreateLinkSpec();
   double specNumber = -1.0;
    jj_consume_token(43);
    spec.linkName = string_literal_content();
    jj_consume_token(44);
    spec.vmfFrom = viMatchFilter();
    jj_consume_token(45);
    jj_consume_token(46);
    jj_consume_token(44);
    spec.vmfTo = viMatchFilter();
    jj_consume_token(45);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FLOATONE:{
      specNumber = number();
      break;
      }
    default:
      jj_la1[20] = jj_gen;
      ;
    }
if (specNumber != -1.0) {
        spec.strength = specNumber;
     }
     KludgeCreateLink.kludgeCreateLink(spec, agent);
  }

/* functions that deal with parameters */
  final public void parameter() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 47:{
      parameterSet();
      break;
      }
    case 48:{
      parameterCreate();
      break;
      }
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* sets the value of a specific parameter $SetParameter area/group/name=value */
  final public void parameterSet() throws ParseException {Token area;
   Token group;
   Token name;
   double value;
    jj_consume_token(47);
    area = jj_consume_token(ID);
    jj_consume_token(8);
    group = jj_consume_token(ID);
    jj_consume_token(8);
    name = jj_consume_token(ID);
    jj_consume_token(39);
    value = number();
Parameters p = agent.getParameters();
      p.set(area.image, group.image, name.image, value);
  }

/* creates a new parameter $CreateParameter area/group/name=value */
  final public void parameterCreate() throws ParseException {Token area;
   Token group;
   Token name;
   double value;
    jj_consume_token(48);
    area = jj_consume_token(ID);
    jj_consume_token(8);
    group = jj_consume_token(ID);
    jj_consume_token(8);
    name = jj_consume_token(ID);
    jj_consume_token(39);
    value = number();
Parameters p = agent.getParameters();
      String documentation = agent.getDocumentation();
      agent.setDocumentation("");
      p.addParam(area.image, group.image, name.image, value, documentation);
  }

/* parses an energy color */
  final public EnergyColors.EnergyColorType energyColor() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 49:{
      jj_consume_token(49);
{if ("" != null) return EnergyColors.EnergyColorType.AM_INSTANCE;}
      break;
      }
    case 50:{
      jj_consume_token(50);
{if ("" != null) return EnergyColors.EnergyColorType.AM_VI;}
      break;
      }
    case 51:{
      jj_consume_token(51);
{if ("" != null) return EnergyColors.EnergyColorType.FOCUS_INSTANCE;}
      break;
      }
    case 52:{
      jj_consume_token(52);
{if ("" != null) return EnergyColors.EnergyColorType.FOCUS_VI;}
      break;
      }
    case 53:{
      jj_consume_token(53);
{if ("" != null) return EnergyColors.EnergyColorType.SHADOW_INSTANCE;}
      break;
      }
    case 54:{
      jj_consume_token(54);
{if ("" != null) return EnergyColors.EnergyColorType.SHADOW_VI;}
      break;
      }
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* creates a new energy type CreateEnergy name Of Type FOCUS_INSTANCE With E2S = param */
  final public void energyCreate() throws ParseException {String name;
   EnergyColors.EnergyColorType type;
   double e2s;
    jj_consume_token(55);
    name = string_literal_content();
    jj_consume_token(56);
    jj_consume_token(57);
    type = energyColor();
    jj_consume_token(40);
    jj_consume_token(58);
    jj_consume_token(39);
    e2s = number();
agent.getEnergyColors().createEnergy(name, type, e2s);
  }

/* turns on a performance meter */
  final public void performanceMeter() throws ParseException {String param;
    jj_consume_token(59);
    param = string_literal();
PerformanceMeter pm = agent.getDebugInfo().getPerformanceMeter();
      switch (param) {
        case "\u005c"Reset\u005c"":
            pm.timeCountReset();
            break;
        default:
            {if (true) throw new Error("$PerformanceMeter invalid command " + param);}
      }
  }

/* all the commands with start with $Create or $Update */
  final public void create() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 60:{
      jj_consume_token(60);
      break;
      }
    case 61:{
      jj_consume_token(61);
      break;
      }
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 62:{
      createConcept();
      break;
      }
    case 64:{
      createConceptImpact();
      break;
      }
    case 66:{
      createConceptOverlap();
      break;
      }
    case 70:{
      createVerb();
      break;
      }
    case 71:{
      createMetaVerb();
      break;
      }
    case 73:{
      createRelation();
      break;
      }
    case 74:{
      createVerbImpact();
      break;
      }
    case 75:{
      createVerbOverlap();
      break;
      }
    case 76:{
      createWord();
      break;
      }
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* create or update a concept */
  final public void createConcept() throws ParseException {Token t;
   double conceptArea = 1.0;
    jj_consume_token(62);
    t = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 40:{
      jj_consume_token(40);
      jj_consume_token(63);
      jj_consume_token(39);
      conceptArea = number();
      break;
      }
    default:
      jj_la1[25] = jj_gen;
      ;
    }
String conceptName = t.image;
     Concept concept = cdh.createWithArea(conceptName, conceptArea);
     // gather the documentation into the comment
     String documentation = agent.getDocumentation();
     agent.setDocumentation("");
     concept.setDocumentation(documentation);
     // create the negated concept
     String negationName = AbstractConceptDB.getNegationName(conceptName);
     Concept negatedConcept = cdh.createWithArea(negationName, conceptArea);
     negatedConcept.setDocumentation("Concept that is the negation of concept " + conceptName +
                 ". Documentation of the original concept was:" + documentation);
     // FIXME: is this -1.0 or -area???
     cdh.makeImpact(conceptName, negationName, -1.0);
     cdh.makeImpact(negationName, conceptName, -1.0);
  }

/* specify the impact between one concept and another */
  final public void createConceptImpact() throws ParseException {Token t1;
   Token t2;
   double implication;
    jj_consume_token(64);
    t1 = jj_consume_token(ID);
    jj_consume_token(65);
    t2 = jj_consume_token(ID);
    jj_consume_token(40);
    implication = number();
String firstConceptName = t1.image;
     String secondConceptName = t2.image;
     cdh.makeImpact(firstConceptName, secondConceptName, implication);
     // make the impact of the negated concepts
     String negatedFirstConceptName = AbstractConceptDB.getNegationName(firstConceptName);
     String negatedSecondConceptName = AbstractConceptDB.getNegationName(secondConceptName);
     cdh.makeImpact(negatedFirstConceptName, negatedSecondConceptName, implication);
  }

/* specify the overlap between one concept and another */
  final public void createConceptOverlap() throws ParseException {Token t1;
   Token t2;
   double overlap;
    jj_consume_token(66);
    t1 = jj_consume_token(ID);
    jj_consume_token(67);
    t2 = jj_consume_token(ID);
    jj_consume_token(40);
    overlap = number();
String firstConceptName = t1.image;
     String secondConceptName = t2.image;
     cdh.makeOverlap(firstConceptName, secondConceptName, overlap);
     // make the overlap of the negated concepts
     String negatedFirstConceptName = AbstractConceptDB.getNegationName(firstConceptName);
     String negatedSecondConceptName = AbstractConceptDB.getNegationName(secondConceptName);
     cdh.makeOverlap(negatedFirstConceptName, negatedSecondConceptName, overlap);
  }

/**
    Specifies a concept (without a string sign or a word) with an 
    optional multiplier strength
*/
  final public ConceptOverlay coComponent() throws ParseException {Token t = null;
        String word = null;
        double strength = 1.0;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      t = jj_consume_token(ID);
      break;
      }
    case STRING_DOUBLE_QUOTES:
    case STRING_SINGLE_QUOTES:{
      word = string_literal_content();
      break;
      }
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 39:{
      jj_consume_token(39);
      strength = number();
      break;
      }
    default:
      jj_la1[27] = jj_gen;
      ;
    }
ConceptOverlay retval = new ConceptOverlay(agent);
          if (t != null) { // it was a concept
                         try {
               Concept concept = agent.getConceptDB().getConcept(t.image);
               double area = agent.getConceptDB().getArea(concept);
               retval.addSpecificEnergy(concept, strength * area);
                  } catch(NoSuchConceptOrVerb nscov) {
                                 TextUi.println("FIXME: here I would need to do an in-Xapi exception");
                                 TextUi.println("Could not find concept for " + t.image + " at column" + t.beginColumn);
                                 {if (true) throw new Error("Invalid concept");}
                          }
          } else {
             XapiDictionary xepd = agent.getXapiDictionary();
             ConceptOverlay coWord = xepd.getCoForWord(word);
             retval.addOverlay(coWord);
          }
          {if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/* Parses a concept overlay in the form:
   [ concept, "word", concept1 = 0.6 , "word" = 0.7 ] 
   This is currently only used in concept word specification   
*/
  final public ConceptOverlay co() throws ParseException {Token t;
   double conceptStrength = -1.0;
   ConceptOverlay retval = new ConceptOverlay(agent);
   ConceptOverlay co = null;
   double area = 0.0;
    jj_consume_token(68);
    co = coComponent();
retval.addOverlay(co);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 17:{
        ;
        break;
        }
      default:
        jj_la1[28] = jj_gen;
        break label_4;
      }
      jj_consume_token(17);
      co = coComponent();
retval.addOverlay(co);
    }
    jj_consume_token(69);
{if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/**
    Specifies a component of a verb overlay either as a verb or as a verb word (written with a string mode)
*/
  final public VerbOverlay voComponent() throws ParseException {Token t = null;
        String word = null;
        double strength = 1.0;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ID:{
      t = jj_consume_token(ID);
      break;
      }
    case STRING_DOUBLE_QUOTES:
    case STRING_SINGLE_QUOTES:{
      word = string_literal_content();
      break;
      }
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 39:{
      jj_consume_token(39);
      strength = number();
      break;
      }
    default:
      jj_la1[30] = jj_gen;
      ;
    }
VerbOverlay retval = new VerbOverlay(agent);
        if (t != null) { // it was a concept
           Verb verb = agent.getVerbDB().getConcept(t.image);
           double area = agent.getVerbDB().getArea(verb);
           retval.addSpecificEnergy(verb, strength * area);
        } else {
           XapiDictionary xepd = agent.getXapiDictionary();
           VerbOverlay voWord = xepd.getVoForWord(word);
           retval.addOverlay(voWord);
        }
        {if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/* Parses a verb overlay in the form:
   [ verb, "word", verb1 = 0.6 , "word2" = 0.7 ] 
   This is currently only used in the verb word specification
*/
  final public VerbOverlay vo() throws ParseException {VerbOverlay retval = new VerbOverlay(agent);
   VerbOverlay vo;
    jj_consume_token(68);
    vo = voComponent();
retval.addOverlay(vo);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 17:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_5;
      }
      jj_consume_token(17);
      vo = voComponent();
retval.addOverlay(vo);
    }
    jj_consume_token(69);
{if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/* create or update a verb (that doesn't have a metaverb) */
  final public void createVerb() throws ParseException {Token t;
   double verbArea = 1.0;
    jj_consume_token(70);
    t = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 40:{
      jj_consume_token(40);
      jj_consume_token(63);
      jj_consume_token(39);
      verbArea = number();
      break;
      }
    default:
      jj_la1[32] = jj_gen;
      ;
    }
String verbName = t.image;
    Verb verb = vdh.createWithAreaAndMetaverb(verbName, verbArea, null);
    // gather the documentation into the comment
    String documentation = agent.getDocumentation();
    agent.setDocumentation("");
    verb.setDocumentation(documentation);
    // create the negated verb
    String negationName = AbstractConceptDB.getNegationName(verbName);
    Verb negatedVerb = vdh.createWithAreaAndMetaverb(negationName, verbArea, null);
    negatedVerb.setDocumentation("Verb that is the negation of verb " + verbName +
                 ". Documentation of the original verb was:" + documentation);
    // FIXME: is this -1.0 or -area???
    vdh.makeImpact(verbName, negationName, -1.0);
    vdh.makeImpact(negationName, verbName, -1.0);
  }

/* create or update a verb that relies on a metaverb*/
  final public void createMetaVerb() throws ParseException {Token t;
   double verbArea = 1.0;
   Token t2 = null;
    jj_consume_token(71);
    t = jj_consume_token(ID);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 40:{
      jj_consume_token(40);
      jj_consume_token(63);
      jj_consume_token(39);
      verbArea = number();
      break;
      }
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(72);
    t2 = jj_consume_token(ID);
String verbName = t.image;
    String metaverb = t2.image;
    Verb verb = vdh.createWithAreaAndMetaverb(verbName, verbArea, metaverb);
    // gather the documentation into the comment
    String documentation = agent.getDocumentation();
    agent.setDocumentation("");
    verb.setDocumentation(documentation);
    // create the negated verb - although we are negating a metaverb, the negation will not be a metaverb...
    String negationName = AbstractConceptDB.getNegationName(verbName);
    Verb negatedVerb = vdh.createWithAreaAndMetaverb(negationName, verbArea, null);
    negatedVerb.setDocumentation("Verb that is the negation of verb " + verbName +
                 ". Documentation of the original verb was:" + documentation);
    // FIXME: is this -1.0 or -area???
    vdh.makeImpact(verbName, negationName, -1.0);
    vdh.makeImpact(negationName, verbName, -1.0);
  }

/* create a relation */
  final public void createRelation() throws ParseException {Token t;
   double verbArea = 1.0;
   Token t2 = null;
    jj_consume_token(73);
    t = jj_consume_token(ID);
String verbName = t.image;
    Verb verb = vdh.createWithAreaAndMetaverb(verbName, verbArea, null);
    // gather the documentation into the comment
    String documentation = agent.getDocumentation();
    agent.setDocumentation("");
    verb.setDocumentation(documentation);
    vdh.makeOverlap(verbName, Hardwired.VMC_RELATION, 1.0);
    // FIXME: currently we are not creating negated relations???
    // create the negated verb
    String negationName = AbstractConceptDB.getNegationName(verbName);
    Verb negatedVerb = vdh.createWithAreaAndMetaverb(negationName, verbArea, null);
    vdh.makeOverlap(negationName, Hardwired.VMC_RELATION, 1.0);
    negatedVerb.setDocumentation("Verb that is the negation of verb " + verbName +
                 ". Documentation of the original verb was:" + documentation);
    // FIXME: is this -1.0 or -area???
    vdh.makeImpact(verbName, negationName, -1.0);
    vdh.makeImpact(negationName, verbName, -1.0);
  }

/* specify the impact between one verb and another */
  final public void createVerbImpact() throws ParseException {Token t1;
   Token t2;
   double implication;
    jj_consume_token(74);
    t1 = jj_consume_token(ID);
    jj_consume_token(65);
    t2 = jj_consume_token(ID);
    jj_consume_token(40);
    implication = number();
String firstVerbName = t1.image;
     String secondVerbName = t2.image;
     vdh.makeImpact(firstVerbName, secondVerbName, implication);
     // make the impact of the negated concepts
     String negatedFirstVerbName = AbstractConceptDB.getNegationName(firstVerbName);
     String negatedSecondVerbName = AbstractConceptDB.getNegationName(secondVerbName);
     vdh.makeImpact(negatedFirstVerbName, negatedSecondVerbName, implication);
  }

/* specify the overlap between one verb and another */
  final public void createVerbOverlap() throws ParseException {Token t1;
   Token t2;
   double overlap;
    jj_consume_token(75);
    t1 = jj_consume_token(ID);
    jj_consume_token(67);
    t2 = jj_consume_token(ID);
    jj_consume_token(40);
    overlap = number();
String firstVerbName = t1.image;
     String secondVerbName = t2.image;
     vdh.makeOverlap(firstVerbName, secondVerbName, overlap);
     // make the impact of the negated concepts
     String negatedFirstVerbName = AbstractConceptDB.getNegationName(firstVerbName);
     String negatedSecondVerbName = AbstractConceptDB.getNegationName(secondVerbName);
     vdh.makeOverlap(negatedFirstVerbName, negatedSecondVerbName, overlap);
  }

/* define a word for a concept or a verb */
  final public void createWord() throws ParseException {String word;
   VerbOverlay vo;
    jj_consume_token(76);
    word = string_literal_content();
    jj_consume_token(77);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 62:{
      createWordForConcept(word);
      break;
      }
    case 70:{
      createWordForVerb(word);
      break;
      }
    case 78:{
      createWordForActionVerb(word);
      break;
      }
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* Continues from $Create Word "name" For */
  final public void createWordForConcept(String word) throws ParseException {ConceptOverlay co;
    jj_consume_token(62);
    co = co();
XapiDictionary xepd = agent.getXapiDictionary();
    // gather the documentation into the comment
    String documentation = agent.getDocumentation();
    agent.setDocumentation("");
    xepd.addConceptWord(word, co, documentation);
  }

/* Continues from $Create Word "name" For */
  final public void createWordForVerb(String word) throws ParseException {VerbOverlay vo;
    jj_consume_token(70);
    vo = vo();
XapiDictionary xepd = agent.getXapiDictionary();
     // gather the documentation into the comment
     String documentation = agent.getDocumentation();
     agent.setDocumentation("");
     xepd.addVerbWord(word, vo, documentation);
  }

/* Continues from $Create Word "name" For */
  final public void createWordForActionVerb(String word) throws ParseException {VerbOverlay vo;
    jj_consume_token(78);
    vo = vo();
XapiDictionary xepd = agent.getXapiDictionary();
    // FIXME: replace with Hardwired
    VerbOverlay voAction = xepd.getVoForWord("ActionVerb");
    vo.addOverlay(voAction);
    // gather the documentation into the comment
    String documentation = agent.getDocumentation();
    agent.setDocumentation("");
    xepd.addVerbWord(word, vo, documentation);
  }

/* diffusion activity commands: they can be basically clear and add */
  final public void diffusionActivity() throws ParseException {
    jj_consume_token(79);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 80:{
      diffusionActivityClear();
      break;
      }
    case 82:{
      diffusionActivityAdd();
      break;
      }
    case 87:{
      diffusionActivityUpdate();
      break;
      }
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* clears a particular DA group */
  final public void diffusionActivityClear() throws ParseException {String groupName;
    jj_consume_token(80);
    jj_consume_token(81);
    groupName = string_literal_content();
DaHelper.clearComposite(agent, groupName);
  }

/* adds a new DA to a particular DA group */
  final public void diffusionActivityAdd() throws ParseException {String groupName;
        String daName;
        String daCode;
        Map<String, String> parameters = new HashMap<String, String>();
    jj_consume_token(82);
    jj_consume_token(83);
    jj_consume_token(81);
    groupName = string_literal_content();
    jj_consume_token(84);
    jj_consume_token(85);
    jj_consume_token(40);
    jj_consume_token(86);
    daName = string_literal_content();
    jj_consume_token(72);
    daCode = string_literal_content();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 88:{
      parameters = activityParameters();
      break;
      }
    default:
      jj_la1[36] = jj_gen;
      ;
    }
DaHelper.addDaToComposite(agent, groupName, daName, daCode, parameters);
  }

/* updates the parameters of a particular named DA from a DA group */
  final public void diffusionActivityUpdate() throws ParseException {String groupName;
        String daName;
        Map<String, String> parameters = new HashMap<String, String>();
    jj_consume_token(87);
    jj_consume_token(33);
    jj_consume_token(81);
    groupName = string_literal_content();
    jj_consume_token(85);
    jj_consume_token(40);
    jj_consume_token(86);
    daName = string_literal_content();
    jj_consume_token(40);
    parameters = activityParameters();
DaHelper.updateDaInComposite(agent, groupName, daName, parameters);
  }

/**
 * Parses the activities 
 */
  final public Map<String, String> activityParameters() throws ParseException {String name;
        String value;
        Map<String, String> retval = new HashMap<String, String>();
    jj_consume_token(88);
    name = string_literal_content();
    jj_consume_token(39);
    value = string_literal_content();
retval.put(name, value);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 17:{
        ;
        break;
        }
      default:
        jj_la1[37] = jj_gen;
        break label_6;
      }
      jj_consume_token(17);
      name = string_literal_content();
      jj_consume_token(39);
      value = string_literal_content();
retval.put(name, value);
    }
{if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

/* diffusion activity commands: they can be basically clear and add */
  final public void spikeActivity() throws ParseException {
    jj_consume_token(89);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 80:{
      spikeActivityClear();
      break;
      }
    case 82:{
      spikeActivityAdd();
      break;
      }
    case 87:{
      spikeActivityUpdate();
      break;
      }
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* clears a particular composite SA */
  final public void spikeActivityClear() throws ParseException {String groupName;
    jj_consume_token(80);
    jj_consume_token(81);
    groupName = string_literal_content();
SaHelper.clearComposite(agent, groupName);
  }

/* adds a new SA to a particular composite SA */
  final public void spikeActivityAdd() throws ParseException {String groupName;
        String daName;
        String daCode;
        Map<String, String> parameters = new HashMap<String, String>();
    jj_consume_token(82);
    jj_consume_token(83);
    jj_consume_token(81);
    groupName = string_literal_content();
    jj_consume_token(84);
    jj_consume_token(90);
    jj_consume_token(40);
    jj_consume_token(86);
    daName = string_literal_content();
    jj_consume_token(72);
    daCode = string_literal_content();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 88:{
      parameters = activityParameters();
      break;
      }
    default:
      jj_la1[39] = jj_gen;
      ;
    }
SaHelper.addSaToComposite(agent, groupName, daName, daCode, parameters);
  }

/* updates the parameters of a particular named DA from a DA group */
  final public void spikeActivityUpdate() throws ParseException {String groupName;
        String daName;
        Map<String, String> parameters = new HashMap<String, String>();
    jj_consume_token(87);
    jj_consume_token(33);
    jj_consume_token(81);
    groupName = string_literal_content();
    jj_consume_token(90);
    jj_consume_token(40);
    jj_consume_token(86);
    daName = string_literal_content();
    jj_consume_token(40);
    parameters = activityParameters();
SaHelper.updateSaInComposite(agent, groupName, daName, parameters);
  }

/* metastatement managing observers of the Xapi agent */
  final public void observer() throws ParseException {
    jj_consume_token(91);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 92:{
      observerAdd();
      break;
      }
    case 95:{
      observerRemoveAll();
      break;
      }
    case 96:{
      observerRemove();
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* adding a new observer (of XapiObserver type) */
  final public void observerAdd() throws ParseException {String name;
        String triggerSpec;
        String fileSpec;
    jj_consume_token(92);
    name = string_literal_content();
    jj_consume_token(93);
    triggerSpec = string_literal_content();
    jj_consume_token(94);
    fileSpec = string_literal_content();
File f = IncludeHelper.findXapiFile(fileSpec);
          XapiObserver observer = null;
          try {
              observer = new XapiObserver(f);
          } catch (IOException e) {
              // TODO Auto-generated catch block
              e.printStackTrace();
          }
          observer.addObserveWhat(DebugEventType.AFTER_LOOP_ITEM_EXECUTION);
          agent.addObserver(name, observer);
  }

/* removing all observers from the Xapi agent */
  final public void observerRemoveAll() throws ParseException {
    jj_consume_token(95);
agent.removeAllObservers();
  }

/* removing all observers from the Xapi agent */
  final public void observerRemove() throws ParseException {String name;
    jj_consume_token(96);
    name = string_literal_content();
agent.removeObserver(name);
  }

/* Metastatement for printing something */
  final public void print() throws ParseException {String current = null;
        List<String> list = new ArrayList<String>();
    jj_consume_token(97);
    current = printspec();
list.add(current);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case 17:{
        ;
        break;
        }
      default:
        jj_la1[41] = jj_gen;
        break label_7;
      }
      jj_consume_token(17);
      current = printspec();
list.add(current);
    }
for(String item: list) {
                        TextUi.print(item);
                }
                TextUi.println("");
  }

/* statement for creating namespaces */
  final public void namespace() throws ParseException {String ns;
    jj_consume_token(98);
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case 99:{
      jj_consume_token(99);
      ns = string_literal_content();
agent.getLabelSpaces().setNamespace(ns);
      break;
      }
    case 100:{
      jj_consume_token(100);
agent.getLabelSpaces().createNamespace();
      break;
      }
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/* Various things that can be printed */
  final public String printspec() throws ParseException {String retval = null;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_DOUBLE_QUOTES:
    case STRING_SINGLE_QUOTES:{
      retval = string_literal_content();
      break;
      }
    case 101:{
      jj_consume_token(101);
Set<TraceWhat> traceWhat = new HashSet<TraceWhat>();
                traceWhat.add(TraceWhat.VERBALIZATION);
                retval = ToStringObserver.formatTraceString(agent, DebugEventType.AFTER_LOOP_ITEM_EXECUTION, traceWhat);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
{if ("" != null) return retval;}
    throw new Error("Missing return statement in function");
  }

  final public double number() throws ParseException {Token t;
    t = jj_consume_token(FLOATONE);
{if ("" != null) return Double.parseDouble(t.image);}
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a string literal. The delimiter quotes are part of the returned
   content. The literal can use either single or double quotes, but it will
   always return the values with double quotes.
 */
  final public 
String string_literal() throws ParseException {Token t;
Token t2;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case STRING_DOUBLE_QUOTES:{
      t = jj_consume_token(STRING_DOUBLE_QUOTES);
{if ("" != null) return t.image;}
      break;
      }
    case STRING_SINGLE_QUOTES:{
      t2 = jj_consume_token(STRING_SINGLE_QUOTES);
{if ("" != null) return "\u005c"" + t2.image.substring(1, t2.image.length()-1) + "\u005c"";}
      break;
      }
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Accepts a string literal, but returns its content without the quotes
 */
  final public String string_literal_content() throws ParseException {String value;
    value = string_literal();
{if ("" != null) return value.substring(1, value.length()-1);}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public XapiLangTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[45];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xe0780000,0x70700,0x0,0x0,0x0,0x0,0xf000,0x70000,0x300000,0x800000,0x1000000,0x2000000,0x4000000,0x10000000,0x20000,0x10000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x38818809,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x4,0x410,0x0,0x18000,0x7e0000,0x30000000,0x40000000,0x100,0x0,0x80,0x0,0x0,0x80,0x0,0x100,0x100,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0xa008000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1ec5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4040,0x850000,0x1000000,0x0,0x850000,0x1000000,0x90000000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x60c6,0x0,0x60c0,0x60c0,0x6040,0x6040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x6040,0x0,0x0,0x6040,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x18,0x6020,0x6000,};
   }

  /** Constructor with InputStream. */
  public XapiLang(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public XapiLang(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new XapiLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public XapiLang(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new XapiLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public XapiLang(XapiLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(XapiLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 45; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[111];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 45; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 111; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
